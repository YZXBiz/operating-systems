Mechanism: Address Translation In developing the virtualization of the CPU, we focused on a general mechanism known as limited direct execution (or LDE). The idea behind LDEis simple: for the most part, let the program run directly on the hardware; however, at certain key points in time (such as when a process issues a system call, or a timer interrupt occurs), arrange so that the OS gets involved and makes sure the “right” thing happens. Thus, the OS, with a little hardware support, tries its best to get out of the way of the running program, to deliver an efficient virtualization; however, by interposing at those critical points in time, the OS ensures that it maintains control over the hardware. Efficiency and control together are two of the main goals of any modern operating system. In virtualizing memory, we will pursue a similar strategy, attaining both efficiency and control while providing the desired virtualization. Eff iciency dictates that we make use of hardware support, which at first will be quite rudimentary (e.g., just a few registers) but will grow to be fairly complex (e.g., TLBs, page-table support, and so forth, as you will see). Control implies that the OS ensures that no application is allowed to access any memory but its own; thus, to protect applications from one another, and the OS from applications, we will need help from the hardware here too. Finally, we will need a little more from the VM system, in terms of flexibility; specifically, we’d like for programs to be able to use their address spaces in whatever way they would like, thus making the system easier to program. And thus we arrive at the refined crux: THE CRUX: HOWTOEFFICIENTLY AND FLEXIBLY VIRTUALIZE MEMORY How can we build an efficient virtualization of memory? How do we provide the flexibility needed by applications? How do we maintain control over which memory locations an application can access, and thus ensure that application memory accesses are properly restricted? How do wedoall of this efficiently? 12 MECHANISM: ADDRESS TRANSLATION Thegenerictechniquewewilluse, whichyoucanconsideranaddition to our general approach of limited direct execution, is something that is referred to as hardware-based address translation, or just address translation for short. With address translation, the hardware transforms each memoryaccess(e.g., an instruction fetch, load, or store), changing the virtual address provided by the instruction to a physical address where the desired information is actually located. Thus, on each and every memory reference, an address translation is performed by the hardware to redirect application memory references to their actual locations in memory. Ofcourse, the hardware alone cannot virtualize memory, as it just provides the low-level mechanism for doing so efficiently. The OS must get involved at key points to set up the hardware so that the correct translations take place; it must thus manage memory, keeping track of which locations are free and which are in use, and judiciously intervening to maintain control over how memory is used. Once again the goal of all of this work is to create a beautiful illusion: that the program has its own private memory, where its own code and data reside. Behind that virtual reality lies the ugly physical truth: that many programs are actually sharing memory at the same time, as the CPU(or CPUs) switches between running one program and the next. Through virtualization, the OS (with the hardware’s help) turns the ugly machine reality into a useful, powerful, and easy to use abstraction. 15.1 Assumptions Our first attempts at virtualizing memory will be very simple, almost laughably so. Go ahead, laugh all you want; pretty soon it will be the OS laughing at you, when you try to understand the ins and outs of TLBs, multi-level page tables, and other technical wonders. Don’t like the idea of the OS laughing at you? Well, you may be out of luck then; that’s just howthe OSrolls. Specifically, we will assumefornowthattheuser’saddressspacemust be placed contiguously in physical memory. We will also assume, for simplicity, that the size of the address space is not too big; specifically, that it is less than the size of physical memory. Finally, we will also assume that each address space is exactly the same size. Don’t worry if these assumptions sound unrealistic; we will relax them as we go, thus achieving a realistic virtualization of memory. 15.2 An Example To understand better what we need to do to implement address translation, and why we need such a mechanism, let’s look at a simple example. Imagine there is a process whose address space is as indicated in Figure 15.1. What we are going to examine here is a short code sequence that loads a value from memory, increments it by three, and then stores the value back into memory. You can imagine the C-language representation of this code might look like this: OPERATING SYSTEMS WWW.OSTEP.ORG [VERSION 1.10]MECHANISM:ADDRESSTRANSLATION 3 TIP: INTERPOSITIONISPOWERFUL Interpositionisagenericandpowerful techniquethat isoftenusedto greateffectincomputersystems. Invirtualizingmemory, thehardware willinterposeoneachmemoryaccess,andtranslateeachvirtualaddress issuedbytheprocesstoaphysicaladdresswherethedesiredinformationisactuallystored.However,thegeneraltechniqueofinterpositionis muchmorebroadlyapplicable;indeed,almostanywell-definedinterface canbeinterposedupon,toaddnewfunctionalityorimprovesomeother aspectof thesystem. Oneof theusualbenefitsofsuchanapproachis transparency;theinterpositionoftenisdonewithoutchangingtheinterfaceoftheclient,thusrequiringnochangestosaidclient. voidfunc(){ intx =3000;//thanks,Perry. x =x +3; //lineofcodeweareinterestedin ... Thecompilerturnsthislineofcodeintoassembly,whichmightlook somethinglikethis(inx86assembly).UseobjdumponLinuxorotool onaMactodisassembleit: 128:movl0x0(%ebx),%eax ;load0+ebxintoeax 132:addl$0x03,%eax ;add3toeaxregister 135:movl%eax,0x0(%ebx) ;storeeaxbacktomem Thiscodesnippet isrelativelystraightforward; itpresumesthat the addressofxhasbeenplacedintheregisterebx,andthenloadsthevalue atthataddressintothegeneral-purposeregistereaxusingthemovlinstruction(for“longword”move). Thenext instructionadds3toeax, andthefinalinstructionstoresthevalueineaxbackintomemoryatthat samelocation. InFigure15.1(page4),observehowboththecodeanddataarelaid outintheprocess’saddressspace;thethree-instructioncodesequenceis locatedataddress128(inthecodesectionnearthetop),andthevalue ofthevariablexataddress15KB(inthestacknearthebottom). Inthe figure,theinitialvalueofxis3000,asshowninitslocationonthestack. Whentheseinstructionsrun, fromtheperspectiveoftheprocess, the followingmemoryaccessestakeplace. •Fetchinstructionataddress128 •Executethisinstruction(loadfromaddress15KB) •Fetchinstructionataddress132 •Executethisinstruction(nomemoryreference) •Fetchtheinstructionataddress135 •Executethisinstruction(storetoaddress15KB) ©2008–23,ARPACI-DUSSEAU THREE EASY PIECES4 MECHANISM: ADDRESS TRANSLATION 0KB 1KB 2KB 3KB 4KB 128 132 135 14KB 15KB 16KB movl 0x0(%ebx),%eax addl 0x03, %eax movl %eax,0x0(%ebx) Program Code Heap (free) 3000 Stack Figure 15.1: A Process And Its Address Space OPERATING SYSTEMS WWW.OSTEP.ORG [VERSION 1.10]5 MECHANISM: ADDRESS TRANSLATION 0KB 16KB 32KB 48KB 64KB Operating System (not in use) Code Heap (allocated but not in use) Stack (not in use) Relocated Process Figure 15.2: Physical Memory with a Single Relocated Process From the program’s perspective, its address space starts at address 0 and grows to a maximum of 16 KB; all memory references it generates should be within these bounds. However, to virtualize memory, the OS wants to place the process somewhere else in physical memory, not necessarily at address 0. Thus, we have the problem: how can we relocate this process in memory in a way that is transparent to the process? How can we provide the illusion of a virtual address space starting at 0, when in reality the address space is located at some other physical address? An example of what physical memory might look like once this process’s address space has been placed in memory is found in Figure 15.2. In the figure, you can see the OS using the first slot of physical memory for itself, and that it has relocated the process from the example above into the slot starting at physical memory address 32 KB. The other two slots are free (16 KB-32 KB and 48 KB-64 KB). 15.3 Dynamic (Hardware-based) Relocation To gain some understanding of hardware-based address translation, we’ll first discuss its first incarnation. Introduced in the first time-sharing machinesofthelate1950’sisasimpleideareferredtoasbaseandbounds; the technique is also referred to as dynamic relocation; we’ll use both terms interchangeably [SS74]. Specifically, we’ll need two hardware registers within each CPU: one is called the base register, and the other the bounds (sometimes called a limit register). This base-and-bounds pair is going to allow ustoplacethe ©2008–23, ARPACI-DUSSEAU THREE EASY PIECES6 MECHANISM: ADDRESS TRANSLATION ASIDE: SOFTWARE-BASED RELOCATION In the early days, before hardware support arose, some systems performed a crude form of relocation purely via software methods. The basic technique is referred to as static relocation, in which a piece of software knownas the loader takes an executable that is about to be run and rewrites its addresses to the desired offset in physical memory. For example, if an instruction was a load from address 1000 into a register (e.g., movl 1000, %eax), and the address space of the program was loaded starting at address 3000 (and not 0, as the program thinks), the loader would rewrite the instruction to offset each address by 3000 (e.g., movl 4000, %eax). In this way, a simple static relocation of the process’s address space is achieved. However, static relocation has numerous problems. First and most importantly, it does not provide protection, as processes can generate bad addresses and thus illegally access other process’s or even OS memory; in general, hardware support is likely needed for true protection [WL+93]. Another negative is that once placed, it is difficult to later relocate an address space to another location [M65]. address space anywhere we’d like in physical memory, and do so while ensuring that the process can only access its own address space. In this setup, each program is written and compiled as if it is loaded at address zero. However, when a program starts running, the OS decides where in physical memory it should be loaded and sets the base register to that value. In the example above, the OS decides to load the process at physical address 32 KB and thus sets the base register to this value. Interesting things start to happen when the process is running. Now, when any memory reference is generated by the process, it is translated by the processor in the following manner: physical address = virtual address + base Each memory reference generated by the process is a virtual address; the hardware in turn adds the contents of the base register to this address and the result is a physical address that can be issued to the memory system. To understand this better, let’s trace through what happens when a single instruction is executed. Specifically, let’s look at one instruction from our earlier sequence: 128: movl 0x0(%ebx), %eax The program counter (PC) is set to 128; when the hardware needs to fetch this instruction, it first adds the value to the base register value of 32 KB (32768) to get a physical address of 32896; the hardware then fetches the instruction from that physical address. Next, the processor begins executing the instruction. At some point, the process then issues OPERATING SYSTEMS WWW.OSTEP.ORG [VERSION 1.10]MECHANISM: ADDRESS TRANSLATION 7 TIP: HARDWARE-BASED DYNAMIC RELOCATION With dynamic relocation, a little hardware goes a long way. Namely, a baseregister is used to transform virtual addresses (generated by the program) into physical addresses. A bounds (or limit) register ensures that such addresses are within the confines of the address space. Together they provide a simple and efficient virtualization of memory. the load from virtual address 15 KB, which the processor takes and again adds to the base register (32 KB), getting the final physical address of 47 KBandthus the desired contents. Transforming a virtual address into a physical address is exactly the technique we refer to as address translation; that is, the hardware takes a virtual address the process thinks it is referencing and transforms it into a physical address which is where the data actually resides. Because this relocation of the address happens at runtime, and because we can move address spaces even after the process has started running, the technique is often referred to as dynamic relocation [M65]. Nowyoumight be asking: what happened to that bounds (limit) register? After all, isn’t this the base and bounds approach? Indeed, it is. As you might have guessed, the bounds register is there to help with protection. Specifically, the processor will first check that the memory reference is within bounds to make sure it is legal; in the simple example above, the bounds register would always be set to 16 KB. If a process generates a virtual address that is greater than (or equal to) the bounds, or one that is negative, the CPU will raise an exception, and the process will likely be terminated. The point of the bounds is thus to make sure that all addresses generated by the process are legal and within the “bounds” of the process, as you might have guessed. Weshouldnotethat the base andboundsregisters are hardware structures kept on the chip (one pair per CPU). Sometimes people call the part of the processor that helps with address translation the memory management unit (MMU); as we develop more sophisticated memorymanagement techniques, we will be adding more circuitry to the MMU. A small aside about bound registers, which can be defined in one of two ways. In one way (as above), it holds the size of the address space, and thus the hardware checks the virtual address against it first before adding the base. In the second way, it holds the physical address of the end of the address space, and thus the hardware first adds the base and then makessuretheaddressiswithinbounds. Bothmethodsarelogically equivalent; for simplicity, we’ll usually assume the former method. Example Translations To understand address translation via base-and-bounds in more detail, let’s take a look at anexample. Imagineaprocesswithanaddressspaceof size 4 KB (yes, unrealistically small) has been loaded at physical address 16 KB. Here are the results of a number of address translations: ©2008–23, ARPACI-DUSSEAU THREE EASY PIECES8 MECHANISM: ADDRESS TRANSLATION Virtual Address Physical Address 0 → 1 KB → 3000 → 16 KB 17 KB 19384 4400 → Fault(outofbounds) As you can see from the example, it is easy for you to simply add the base address to the virtual address (which can rightly be viewed as an offset into the address space) to get the resulting physical address. Only if the virtual address is “too big” or negative will the result be a fault, causing an exception to be raised. 15.4 Hardware Support: A Summary Let us now summarize the support we need from the hardware (also see Figure 15.3, page 9). First, as discussed in the chapter on CPU virtualization, we require two different CPU modes. The OS runs in privileged mode (or kernel mode), where it has access to the entire machine; applications run in user mode, where they are limited in what they can do. A single bit, perhaps stored in some kind of processor status word, indicates which mode the CPU is currently running in; upon certain special occasions (e.g., a system call or someotherkindofexceptionorinterrupt), the CPU switches modes. The hardware mustalso provide the base and boundsregisters themselves; each CPUthushasanadditionalpairofregisters, part of the memory management unit (MMU) of the CPU. When a user program is running, the hardware will translate each address, by adding the base value to the virtual address generated by the user program. Thehardwaremust also be able to check whether the address is valid, which is accomplished by using the bounds register and some circuitry within the CPU. The hardware should provide special instructions to modify the base and bounds registers, allowing the OS to change them when different processes run. These instructions are privileged; only in kernel (or privileged) mode can the registers be modified. Imagine the havoc a user process could wreak1 if it could arbitrarily change the base register while 1 Is there anything other than “havoc” that can be “wreaked”? [W17] ASIDE: DATA STRUCTURE — THE FREE LIST The OS must track which parts of free memory are not in use, so as to be able to allocate memory to processes. Many different data structures can of course be used for such a task; the simplest (which we will assume here) is a free list, which simply is a list of the ranges of the physical memorywhich are not currently in use. OPERATING SYSTEMS WWW.OSTEP.ORG [VERSION 1.10]MECHANISM: ADDRESS TRANSLATION 9 Hardware Requirements Notes Privileged mode Needed to prevent user-mode processes from executing privileged operations Base/bounds registers Need pair of registers per CPU to support address translation and bounds checks Ability to translate virtual addresses and check if within bounds Circuitry to do translations and check limits; in this case, quite simple Privileged instruction(s) to update base/bounds OSmust be able to set these values before letting a user program run Privileged instruction(s) to register exception handlers OSmust be able to tell hardware what code to run if exception occurs Ability to raise exceptions When processes try to access privileged instructions or out-of-bounds memory Figure 15.3: Dynamic Relocation: Hardware Requirements running. Imagine it! And then quickly flush such dark thoughts from your mind, as they are the ghastly stuff of which nightmares are made. Finally, the CPU must be able to generate exceptions in situations where a user program tries to access memory illegally (with an address that is “out of bounds”); in this case, the CPU should stop executing the user program andarrange for the OS“out-of-bounds” exception handler to run. The OShandlercanthenfigureouthowtoreact, inthis case likely terminating the process. Similarly, if a user program tries to change the values ofthe(privileged) base andboundsregisters, theCPUshouldraise an exception and run the “tried to execute a privileged operation while in user mode” handler. The CPU also must provide a method to inform it of the location of these handlers; a few more privileged instructions are thus needed. 15.5 Operating System Issues Just as the hardware provides new features to support dynamic relocation, the OS now has new issues it must handle; the combination of hardware support and OS management leads to the implementation of a simple virtual memory. Specifically, there are a few critical junctures where the OS must get involved to implement our base-and-bounds version of virtual memory. First, the OS must take action when a process is created, finding space for its address space in memory. Fortunately, given our assumptions that each address space is (a) smaller than the size of physical memory and (b) the same size, this is quite easy for the OS; it can simply view physical memory as an array of slots, and track whether each one is free or in use. When a new process is created, the OS will have to search a data structure (often called a free list) to find room for the new address space and then mark it used. With variable-sized address spaces, life is more complicated, but we will leave that concern for future chapters. ©2008–23, ARPACI-DUSSEAU THREE EASY PIECES10 MECHANISM: ADDRESS TRANSLATION OSRequirements Notes Memorymanagement Need to allocate memory for new processes; Reclaim memory from terminated processes; Generally manage memory via free list Base/bounds management Must set base/bounds properly upon context switch Exception handling Code to run when exceptions arise; likely action is to terminate offending process Figure 15.4: Dynamic Relocation: Operating System Responsibilities Let’s look at an example. In Figure 15.2 (page 5), you can see the OS using the first slot of physical memory for itself, and that it has relocated the processfromtheexampleaboveintotheslotstartingatphysicalmemory address 32 KB. The other two slots are free (16 KB-32 KB and 48 KB64 KB); thus, the free list should consist of these two entries. Second, the OS must do some workwhenaprocess is terminated (i.e., when it exits gracefully, or is forcefully killed because it misbehaved), reclaiming all of its memory for use in other processes or the OS. Upon termination of a process, the OS thus puts its memory back on the free list, and cleans up any associated data structures as need be. Third, the OS mustalsoperformafewadditionalsteps whenacontext switch occurs. There is only one base and bounds register pair on each CPU, after all, and their values differ for each running program, as each program is loaded at a different physical address in memory. Thus, the OS must save and restore the base-and-bounds pair when it switches between processes. Specifically, when the OS decides to stop running a process, it must save the values of the base and bounds registers to memory, in some per-process structure such as the process structure or process control block (PCB). Similarly, when the OS resumes a running process (or runs it the first time), it must set the values of the base and bounds on the CPU to the correct values for this process. Weshould note that when a process is stopped (i.e., not running), it is possible for the OS to move an address space from one location in memory to another rather easily. To move a process’s address space, the OS f irst deschedules the process; then, the OS copies the address space from the current location to the new location; finally, the OS updates the saved base register (in the process structure) to point to the new location. When the process is resumed, its (new) base register is restored, and it begins running again, oblivious that its instructions and data are now in a completely new spot in memory. Fourth, the OS must provide exception handlers, or functions to be called, as discussed above; the OS installs these handlers at boot time (via privileged instructions). For example, if a process tries to access memory outside its bounds, the CPU will raise an exception; the OS must be prepared totakeaction whensuchanexceptionarises. Thecommonreaction of the OSwillbeoneofhostility: it will likely terminate the offending process. The OS should be highly protective of the machine it is running, and thus it does not take kindly to a process trying to access memory or OPERATING SYSTEMS WWW.OSTEP.ORG [VERSION 1.10]MECHANISM: ADDRESS TRANSLATION 11 OS@boot (kernel mode) initialize trap table Hardware (No Program Yet) remember addresses of... system call handler timer handler illegal mem-access handler illegal instruction handler start interrupt timer initialize process table initialize free list start timer; interrupt after X ms Figure 15.5: Limited Direct Execution (Dynamic Relocation) @ Boot execute instructions that it shouldn’t. Bye bye, misbehaving process; it’s been nice knowing you. Figures 15.5 and 15.6 (page 12) illustrate much of the hardware/OS interaction in a timeline. The first figure shows what the OS does at boot time to ready the machine for use, and the second shows what happens when aprocess (Process A) starts running; note how its memory translations are handled by the hardware with no OS intervention. At some point (middle of second figure), a timer interrupt occurs, and the OS switches to Process B, which executes a “bad load” (to an illegal memory address); at that point, the OS must get involved, terminating the process and cleaning up by freeing B’s memory and removing its entry from the process table. As you can see from the figures, we are still following the basic approach of limited direct execution. In most cases, the OS just sets up the hardware appropriately and lets the process run directly on the CPU; only when the process misbehaves does the OS have to become involved. 15.6 Summary In this chapter, we have extended the concept of limited direct execution with a specific mechanism used in virtual memory, known as address translation. With address translation, the OS can control each and every memory access from a process, ensuring the accesses stay within the bounds of the address space. Key to the efficiency of this technique is hardware support, which performs the translation quickly for each access, turning virtual addresses (the process’s view of memory) into physical ones (the actual view). All of this is performed in a way that is transparent to the process that has been relocated; the process has no idea its memoryreferences are being translated, making for a wonderful illusion. Wehavealsoseenoneparticularformofvirtualization, known as base and bounds or dynamic relocation. Base-and-bounds virtualization is quite efficient, as only a little more hardware logic is required to add a ©2008–23, ARPACI-DUSSEAU THREE EASY PIECES12 MECHANISM: ADDRESS TRANSLATION OS@run (kernel mode) Hardware Program (user mode) To start process A: allocate entry in process table alloc memory for process set base/bound registers return-from-trap (into A) Handle timer decide: stop A, run B call switch() routine save regs(A) to proc-struct(A) (including base/bounds) restore regs(B) from proc-struct(B) (including base/bounds) return-from-trap (into B) Handle the trap decide to kill process B deallocate B’s memory free B’s entry in process table restore registers of A move to user mode jump to A’s (initial) PC translate virtual address perform fetch if explicit load/store: ensure address is legal translate virtual address perform load/store Timer interrupt move to kernel mode jump to handler restore registers of B move to user mode jump to B’s PC Load is out-of-bounds; move to kernel mode jump to trap handler Process A runs Fetch instruction Execute instruction (A runs...) Process B runs Execute bad load Figure 15.6: Limited Direct Execution (Dynamic Relocation) @ Runtime OPERATING SYSTEMS WWW.OSTEP.ORG [VERSION 1.10]MECHANISM: ADDRESS TRANSLATION 13 base register to the virtual address and check that the address generated by the process is in bounds. Base-and-bounds also offers protection; the OS and hardware combine to ensure no process can generate memory references outside its own address space. Protection is certainly one of the most important goals of the OS; without it, the OS could not control the machine (if processes were free to overwrite memory, they could easily do nasty things like overwrite the trap table and take over the system). Unfortunately, this simple technique of dynamic relocation does have its inefficiencies. For example, as you can see in Figure 15.2 (page 5), the relocated process is using physical memory from 32 KB to 48 KB; however, because the process stack and heap are not too big, all of the space between the two is simply wasted. This type of waste is usually called internal fragmentation, as the space inside the allocated unit is not all used (i.e., is fragmented) and thus wasted. In our current approach, although there might be enough physical memory for more processes, we are currently restricted to placing an address space in a fixed-sized slot and thus internal fragmentation can arise2. Thus, we are going to need more sophisticated machinery, to try to better utilize physical memory and avoid internal fragmentation. Our first attempt will be a slight generalization of base and bounds known as segmentation, which we will discuss next.